import oracledb from 'oracledb';
import * as dotenv from 'dotenv';

dotenv.config();

// Set TNS_ADMIN BEFORE initializing Oracle Client
process.env.TNS_ADMIN = '/home/ubuntu/cto-aipa/wallet';

// Use thick mode with Oracle Instant Client for better wallet support
try {
  oracledb.initOracleClient({ 
    libDir: '/opt/instantclient_23_4'
  });
  console.log('‚úÖ Oracle Thick Mode initialized');
  console.log(`üìÅ TNS_ADMIN: ${process.env.TNS_ADMIN}`);
} catch (err: any) {
  if (err.message.includes('already been initialized')) {
    console.log('‚úÖ Oracle Thick Mode already initialized');
  } else {
    console.error('‚ùå Oracle Thick Mode error:', err);
  }
}

interface DBConfig {
  user: string;
  password: string;
  connectionString: string;
}

const dbConfig: DBConfig = {
  user: process.env.DB_USER!,
  password: process.env.DB_PASSWORD!,
  connectionString: process.env.DB_SERVICE_NAME!
};

async function initializeDatabase() {
  let connection;
  try {
    console.log(`üîå Connecting to ${dbConfig.connectionString}...`);
    connection = await oracledb.getConnection(dbConfig);
    console.log('üîó Connected to Oracle Autonomous Database (mTLS)');

    // Original memory table
    await connection.execute(`
      BEGIN
        EXECUTE IMMEDIATE 'CREATE TABLE aipa_memory (
          id RAW(16) DEFAULT SYS_GUID() PRIMARY KEY,
          aipa_type VARCHAR2(50) NOT NULL,
          action VARCHAR2(100) NOT NULL,
          context CLOB,
          result CLOB,
          metadata CLOB,
          created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
        )';
      EXCEPTION
        WHEN OTHERS THEN
          IF SQLCODE != -955 THEN
            RAISE;
          END IF;
      END;
    `);

    // Technical debt tracking table
    await connection.execute(`
      BEGIN
        EXECUTE IMMEDIATE 'CREATE TABLE tech_debt (
          id RAW(16) DEFAULT SYS_GUID() PRIMARY KEY,
          repo VARCHAR2(100) NOT NULL,
          description CLOB NOT NULL,
          severity VARCHAR2(20) DEFAULT ''medium'',
          status VARCHAR2(20) DEFAULT ''open'',
          created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
          resolved_at TIMESTAMP
        )';
      EXCEPTION
        WHEN OTHERS THEN
          IF SQLCODE != -955 THEN
            RAISE;
          END IF;
      END;
    `);

    // Architectural decisions table
    await connection.execute(`
      BEGIN
        EXECUTE IMMEDIATE 'CREATE TABLE arch_decisions (
          id RAW(16) DEFAULT SYS_GUID() PRIMARY KEY,
          repo VARCHAR2(100),
          title VARCHAR2(500) NOT NULL,
          description CLOB NOT NULL,
          rationale CLOB,
          created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
        )';
      EXCEPTION
        WHEN OTHERS THEN
          IF SQLCODE != -955 THEN
            RAISE;
          END IF;
      END;
    `);

    // Pending code for approval workflow
    await connection.execute(`
      BEGIN
        EXECUTE IMMEDIATE 'CREATE TABLE pending_code (
          id RAW(16) DEFAULT SYS_GUID() PRIMARY KEY,
          chat_id NUMBER NOT NULL,
          repo VARCHAR2(100) NOT NULL,
          task CLOB NOT NULL,
          filename VARCHAR2(500) NOT NULL,
          code CLOB NOT NULL,
          commit_message VARCHAR2(500),
          pr_title VARCHAR2(500),
          pr_body CLOB,
          status VARCHAR2(20) DEFAULT ''pending'',
          created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
        )';
      EXCEPTION
        WHEN OTHERS THEN
          IF SQLCODE != -955 THEN
            RAISE;
          END IF;
      END;
    `);

    // Alert preferences (persistent)
    await connection.execute(`
      BEGIN
        EXECUTE IMMEDIATE 'CREATE TABLE alert_preferences (
          chat_id NUMBER PRIMARY KEY,
          alerts_enabled NUMBER(1) DEFAULT 1,
          daily_briefing NUMBER(1) DEFAULT 1,
          created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
        )';
      EXCEPTION
        WHEN OTHERS THEN
          IF SQLCODE != -955 THEN
            RAISE;
          END IF;
      END;
    `);

    console.log('‚úÖ Database schema initialized (5 tables)');
  } catch (err) {
    console.error('‚ùå Database initialization error:', err);
    throw err;
  } finally {
    if (connection) {
      await connection.close();
    }
  }
}

async function saveMemory(aipaType: string, action: string, context: any, result: any, metadata: any) {
  let connection;
  try {
    connection = await oracledb.getConnection(dbConfig);
    await connection.execute(
      `INSERT INTO aipa_memory (aipa_type, action, context, result, metadata)
       VALUES (:aipaType, :action, :context, :result, :metadata)`,
      {
        aipaType,
        action,
        context: JSON.stringify(context),
        result: JSON.stringify(result),
        metadata: JSON.stringify(metadata)
      },
      { autoCommit: true }
    );
    console.log('üíæ Memory saved');
  } catch (err) {
    console.error('‚ùå Save memory error:', err);
  } finally {
    if (connection) {
      await connection.close();
    }
  }
}

async function getRelevantMemory(aipaType: string, action: string, limit: number = 5) {
  let connection;
  try {
    connection = await oracledb.getConnection(dbConfig);
    const result = await connection.execute(
      `SELECT context, result, metadata, created_at
       FROM aipa_memory
       WHERE aipa_type = :aipaType AND action = :action
       ORDER BY created_at DESC
       FETCH FIRST :limit ROWS ONLY`,
      { aipaType, action, limit }
    );
    return result.rows;
  } catch (err) {
    console.error('‚ùå Get memory error:', err);
    return [];
  } finally {
    if (connection) {
      await connection.close();
    }
  }
}

// =============================================================================
// TECHNICAL DEBT FUNCTIONS
// =============================================================================

async function addTechDebt(repo: string, description: string, severity: string = 'medium'): Promise<string | null> {
  let connection;
  try {
    connection = await oracledb.getConnection(dbConfig);
    const result = await connection.execute(
      `INSERT INTO tech_debt (repo, description, severity) 
       VALUES (:repo, :description, :severity)
       RETURNING RAWTOHEX(id) INTO :id`,
      {
        repo,
        description,
        severity,
        id: { dir: oracledb.BIND_OUT, type: oracledb.STRING, maxSize: 32 }
      },
      { autoCommit: true }
    );
    const outBinds = result.outBinds as { id: string[] };
    console.log('üìã Tech debt added');
    return outBinds.id[0] || null;
  } catch (err) {
    console.error('‚ùå Add tech debt error:', err);
    return null;
  } finally {
    if (connection) await connection.close();
  }
}

async function getTechDebt(repo?: string, status: string = 'open'): Promise<any[]> {
  let connection;
  try {
    connection = await oracledb.getConnection(dbConfig);
    let query = `SELECT RAWTOHEX(id) as id, repo, description, severity, status, created_at 
                 FROM tech_debt WHERE status = :status`;
    const params: any = { status };
    
    if (repo) {
      query += ` AND repo = :repo`;
      params.repo = repo;
    }
    query += ` ORDER BY created_at DESC FETCH FIRST 20 ROWS ONLY`;
    
    const result = await connection.execute(query, params);
    return result.rows || [];
  } catch (err) {
    console.error('‚ùå Get tech debt error:', err);
    return [];
  } finally {
    if (connection) await connection.close();
  }
}

async function resolveTechDebt(debtId: string): Promise<boolean> {
  let connection;
  try {
    connection = await oracledb.getConnection(dbConfig);
    await connection.execute(
      `UPDATE tech_debt SET status = 'resolved', resolved_at = CURRENT_TIMESTAMP 
       WHERE id = HEXTORAW(:debtId)`,
      { debtId },
      { autoCommit: true }
    );
    console.log('‚úÖ Tech debt resolved');
    return true;
  } catch (err) {
    console.error('‚ùå Resolve tech debt error:', err);
    return false;
  } finally {
    if (connection) await connection.close();
  }
}

// =============================================================================
// ARCHITECTURAL DECISIONS FUNCTIONS
// =============================================================================

async function addDecision(title: string, description: string, rationale: string, repo?: string): Promise<string | null> {
  let connection;
  try {
    connection = await oracledb.getConnection(dbConfig);
    const result = await connection.execute(
      `INSERT INTO arch_decisions (repo, title, description, rationale) 
       VALUES (:repo, :title, :description, :rationale)
       RETURNING RAWTOHEX(id) INTO :id`,
      {
        repo: repo || null,
        title,
        description,
        rationale,
        id: { dir: oracledb.BIND_OUT, type: oracledb.STRING, maxSize: 32 }
      },
      { autoCommit: true }
    );
    const outBinds = result.outBinds as { id: string[] };
    console.log('üèõÔ∏è Decision recorded');
    return outBinds.id[0] || null;
  } catch (err) {
    console.error('‚ùå Add decision error:', err);
    return null;
  } finally {
    if (connection) await connection.close();
  }
}

async function getDecisions(repo?: string, limit: number = 10): Promise<any[]> {
  let connection;
  try {
    connection = await oracledb.getConnection(dbConfig);
    let query = `SELECT RAWTOHEX(id) as id, repo, title, description, rationale, created_at 
                 FROM arch_decisions`;
    const params: any = { limit };
    
    if (repo) {
      query += ` WHERE repo = :repo`;
      params.repo = repo;
    }
    query += ` ORDER BY created_at DESC FETCH FIRST :limit ROWS ONLY`;
    
    const result = await connection.execute(query, params);
    return result.rows || [];
  } catch (err) {
    console.error('‚ùå Get decisions error:', err);
    return [];
  } finally {
    if (connection) await connection.close();
  }
}

// =============================================================================
// PENDING CODE FUNCTIONS (for approval workflow)
// =============================================================================

async function savePendingCode(
  chatId: number, 
  repo: string, 
  task: string, 
  filename: string, 
  code: string,
  commitMessage: string,
  prTitle: string,
  prBody: string
): Promise<string | null> {
  let connection;
  try {
    connection = await oracledb.getConnection(dbConfig);
    // Clear any existing pending code for this chat
    await connection.execute(
      `DELETE FROM pending_code WHERE chat_id = :chatId AND status = 'pending'`,
      { chatId },
      { autoCommit: false }
    );
    
    const result = await connection.execute(
      `INSERT INTO pending_code (chat_id, repo, task, filename, code, commit_message, pr_title, pr_body) 
       VALUES (:chatId, :repo, :task, :filename, :code, :commitMessage, :prTitle, :prBody)
       RETURNING RAWTOHEX(id) INTO :id`,
      {
        chatId,
        repo,
        task,
        filename,
        code,
        commitMessage,
        prTitle,
        prBody,
        id: { dir: oracledb.BIND_OUT, type: oracledb.STRING, maxSize: 32 }
      },
      { autoCommit: true }
    );
    const outBinds = result.outBinds as { id: string[] };
    console.log('üíæ Pending code saved');
    return outBinds.id[0] || null;
  } catch (err) {
    console.error('‚ùå Save pending code error:', err);
    return null;
  } finally {
    if (connection) await connection.close();
  }
}

async function getPendingCode(chatId: number): Promise<any | null> {
  let connection;
  try {
    connection = await oracledb.getConnection(dbConfig);
    const result = await connection.execute(
      `SELECT RAWTOHEX(id) as id, repo, task, filename, code, commit_message, pr_title, pr_body, created_at
       FROM pending_code 
       WHERE chat_id = :chatId AND status = 'pending'
       ORDER BY created_at DESC FETCH FIRST 1 ROW ONLY`,
      { chatId }
    );
    if (result.rows && result.rows.length > 0) {
      return result.rows[0];
    }
    return null;
  } catch (err) {
    console.error('‚ùå Get pending code error:', err);
    return null;
  } finally {
    if (connection) await connection.close();
  }
}

async function clearPendingCode(chatId: number, status: string = 'approved'): Promise<boolean> {
  let connection;
  try {
    connection = await oracledb.getConnection(dbConfig);
    await connection.execute(
      `UPDATE pending_code SET status = :status WHERE chat_id = :chatId AND status = 'pending'`,
      { chatId, status },
      { autoCommit: true }
    );
    return true;
  } catch (err) {
    console.error('‚ùå Clear pending code error:', err);
    return false;
  } finally {
    if (connection) await connection.close();
  }
}

// =============================================================================
// ALERT PREFERENCES FUNCTIONS (persistent)
// =============================================================================

async function getAlertPreferences(chatId: number): Promise<{ alertsEnabled: boolean; dailyBriefing: boolean } | null> {
  let connection;
  try {
    connection = await oracledb.getConnection(dbConfig);
    const result = await connection.execute(
      `SELECT alerts_enabled, daily_briefing FROM alert_preferences WHERE chat_id = :chatId`,
      { chatId }
    );
    if (result.rows && result.rows.length > 0) {
      const row = result.rows[0] as [number, number];
      return {
        alertsEnabled: row[0] === 1,
        dailyBriefing: row[1] === 1
      };
    }
    return null;
  } catch (err) {
    console.error('‚ùå Get alert preferences error:', err);
    return null;
  } finally {
    if (connection) await connection.close();
  }
}

async function setAlertPreferences(chatId: number, alertsEnabled: boolean, dailyBriefing: boolean = true): Promise<boolean> {
  let connection;
  try {
    connection = await oracledb.getConnection(dbConfig);
    await connection.execute(
      `MERGE INTO alert_preferences ap
       USING (SELECT :chatId as chat_id FROM dual) src
       ON (ap.chat_id = src.chat_id)
       WHEN MATCHED THEN UPDATE SET alerts_enabled = :alertsEnabled, daily_briefing = :dailyBriefing
       WHEN NOT MATCHED THEN INSERT (chat_id, alerts_enabled, daily_briefing) VALUES (:chatId, :alertsEnabled, :dailyBriefing)`,
      { 
        chatId, 
        alertsEnabled: alertsEnabled ? 1 : 0, 
        dailyBriefing: dailyBriefing ? 1 : 0 
      },
      { autoCommit: true }
    );
    return true;
  } catch (err) {
    console.error('‚ùå Set alert preferences error:', err);
    return false;
  } finally {
    if (connection) await connection.close();
  }
}

async function getAllAlertChatIds(): Promise<number[]> {
  let connection;
  try {
    connection = await oracledb.getConnection(dbConfig);
    const result = await connection.execute(
      `SELECT chat_id FROM alert_preferences WHERE alerts_enabled = 1`
    );
    if (result.rows) {
      return result.rows.map((row: any) => row[0] as number);
    }
    return [];
  } catch (err) {
    console.error('‚ùå Get all alert chat IDs error:', err);
    return [];
  } finally {
    if (connection) await connection.close();
  }
}

// =============================================================================
// LESSONS LEARNED - CTO learns from experience!
// =============================================================================

async function initLessonsTable(): Promise<void> {
  let connection;
  try {
    connection = await oracledb.getConnection(dbConfig);
    await connection.execute(`
      CREATE TABLE lessons (
        id RAW(16) DEFAULT SYS_GUID() PRIMARY KEY,
        category VARCHAR2(50),
        context VARCHAR2(500),
        action_taken VARCHAR2(1000),
        outcome VARCHAR2(50),
        lesson_learned VARCHAR2(1000),
        repo VARCHAR2(100),
        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
      )
    `);
    await connection.commit();
    console.log('‚úÖ Lessons table created');
  } catch (err: any) {
    if (err.errorNum === 955) {
      // Table already exists
    } else {
      console.error('Lessons table error:', err);
    }
  } finally {
    if (connection) await connection.close();
  }
}

async function saveLesson(
  category: string,
  context: string,
  actionTaken: string,
  outcome: 'success' | 'failure' | 'partial',
  lessonLearned: string,
  repo?: string
): Promise<string | null> {
  let connection;
  try {
    connection = await oracledb.getConnection(dbConfig);
    const result = await connection.execute(
      `INSERT INTO lessons (category, context, action_taken, outcome, lesson_learned, repo)
       VALUES (:category, :context, :action, :outcome, :lesson, :repo)
       RETURNING RAWTOHEX(id) INTO :id`,
      {
        category,
        context: context.substring(0, 500),
        action: actionTaken.substring(0, 1000),
        outcome,
        lesson: lessonLearned.substring(0, 1000),
        repo: repo || null,
        id: { dir: oracledb.BIND_OUT, type: oracledb.STRING }
      }
    );
    await connection.commit();
    return (result.outBinds as any).id[0];
  } catch (err) {
    console.error('‚ùå Save lesson error:', err);
    return null;
  } finally {
    if (connection) await connection.close();
  }
}

async function getLessons(category?: string, limit: number = 10): Promise<any[]> {
  let connection;
  try {
    connection = await oracledb.getConnection(dbConfig);
    let query = `SELECT RAWTOHEX(id) as id, category, context, action_taken, outcome, lesson_learned, repo, created_at
                 FROM lessons`;
    const params: any = { limit };
    
    if (category) {
      query += ` WHERE category = :category`;
      params.category = category;
    }
    query += ` ORDER BY created_at DESC FETCH FIRST :limit ROWS ONLY`;
    
    const result = await connection.execute(query, params);
    return result.rows || [];
  } catch (err) {
    console.error('‚ùå Get lessons error:', err);
    return [];
  } finally {
    if (connection) await connection.close();
  }
}

async function getSuccessPatterns(repo?: string): Promise<any[]> {
  let connection;
  try {
    connection = await oracledb.getConnection(dbConfig);
    let query = `SELECT category, action_taken, lesson_learned, repo
                 FROM lessons WHERE outcome = 'success'`;
    const params: any = {};
    
    if (repo) {
      query += ` AND repo = :repo`;
      params.repo = repo;
    }
    query += ` ORDER BY created_at DESC FETCH FIRST 20 ROWS ONLY`;
    
    const result = await connection.execute(query, params);
    return result.rows || [];
  } catch (err) {
    console.error('‚ùå Get success patterns error:', err);
    return [];
  } finally {
    if (connection) await connection.close();
  }
}

// =============================================================================
// STRATEGIC DATA - Track ecosystem health and priorities
// =============================================================================

async function initStrategicTable(): Promise<void> {
  let connection;
  try {
    connection = await oracledb.getConnection(dbConfig);
    await connection.execute(`
      CREATE TABLE strategic_insights (
        id RAW(16) DEFAULT SYS_GUID() PRIMARY KEY,
        insight_type VARCHAR2(50),
        repo VARCHAR2(100),
        insight_text VARCHAR2(2000),
        priority NUMBER(1),
        status VARCHAR2(20) DEFAULT 'active',
        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
        resolved_at TIMESTAMP
      )
    `);
    await connection.commit();
    console.log('‚úÖ Strategic insights table created');
  } catch (err: any) {
    if (err.errorNum === 955) {
      // Table already exists
    } else {
      console.error('Strategic table error:', err);
    }
  } finally {
    if (connection) await connection.close();
  }
}

async function saveInsight(
  insightType: string,
  insightText: string,
  priority: number,
  repo?: string
): Promise<string | null> {
  let connection;
  try {
    connection = await oracledb.getConnection(dbConfig);
    const result = await connection.execute(
      `INSERT INTO strategic_insights (insight_type, repo, insight_text, priority)
       VALUES (:type, :repo, :text, :priority)
       RETURNING RAWTOHEX(id) INTO :id`,
      {
        type: insightType,
        repo: repo || null,
        text: insightText.substring(0, 2000),
        priority,
        id: { dir: oracledb.BIND_OUT, type: oracledb.STRING }
      }
    );
    await connection.commit();
    return (result.outBinds as any).id[0];
  } catch (err) {
    console.error('‚ùå Save insight error:', err);
    return null;
  } finally {
    if (connection) await connection.close();
  }
}

async function getActiveInsights(): Promise<any[]> {
  let connection;
  try {
    connection = await oracledb.getConnection(dbConfig);
    const result = await connection.execute(
      `SELECT RAWTOHEX(id) as id, insight_type, repo, insight_text, priority, created_at
       FROM strategic_insights 
       WHERE status = 'active'
       ORDER BY priority DESC, created_at DESC
       FETCH FIRST 20 ROWS ONLY`
    );
    return result.rows || [];
  } catch (err) {
    console.error('‚ùå Get insights error:', err);
    return [];
  } finally {
    if (connection) await connection.close();
  }
}

async function resolveInsight(insightId: string): Promise<boolean> {
  let connection;
  try {
    connection = await oracledb.getConnection(dbConfig);
    await connection.execute(
      `UPDATE strategic_insights 
       SET status = 'resolved', resolved_at = CURRENT_TIMESTAMP
       WHERE id = HEXTORAW(:id)`,
      { id: insightId }
    );
    await connection.commit();
    return true;
  } catch (err) {
    console.error('‚ùå Resolve insight error:', err);
    return false;
  } finally {
    if (connection) await connection.close();
  }
}

// =============================================================================
// SERVICE HEALTH TRACKING
// =============================================================================

async function initHealthTable(): Promise<void> {
  let connection;
  try {
    connection = await oracledb.getConnection(dbConfig);
    await connection.execute(`
      CREATE TABLE service_health (
        id RAW(16) DEFAULT SYS_GUID() PRIMARY KEY,
        service_name VARCHAR2(100),
        status VARCHAR2(20),
        response_time NUMBER,
        error_message VARCHAR2(500),
        checked_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
      )
    `);
    await connection.commit();
    console.log('‚úÖ Service health table created');
  } catch (err: any) {
    if (err.errorNum === 955) {
      // Table already exists
    } else {
      console.error('Health table error:', err);
    }
  } finally {
    if (connection) await connection.close();
  }
}

async function saveHealthCheck(
  serviceName: string,
  status: 'healthy' | 'degraded' | 'down',
  responseTime?: number,
  errorMessage?: string
): Promise<void> {
  let connection;
  try {
    connection = await oracledb.getConnection(dbConfig);
    await connection.execute(
      `INSERT INTO service_health (service_name, status, response_time, error_message)
       VALUES (:name, :status, :time, :error)`,
      {
        name: serviceName,
        status,
        time: responseTime || null,
        error: errorMessage?.substring(0, 500) || null
      }
    );
    await connection.commit();
  } catch (err) {
    console.error('‚ùå Save health check error:', err);
  } finally {
    if (connection) await connection.close();
  }
}

async function getHealthHistory(serviceName?: string, hours: number = 24): Promise<any[]> {
  let connection;
  try {
    connection = await oracledb.getConnection(dbConfig);
    let query = `SELECT service_name, status, response_time, error_message, checked_at
                 FROM service_health
                 WHERE checked_at > CURRENT_TIMESTAMP - INTERVAL '${hours}' HOUR`;
    const params: any = {};
    
    if (serviceName) {
      query += ` AND service_name = :name`;
      params.name = serviceName;
    }
    query += ` ORDER BY checked_at DESC FETCH FIRST 100 ROWS ONLY`;
    
    const result = await connection.execute(query, params);
    return result.rows || [];
  } catch (err) {
    console.error('‚ùå Get health history error:', err);
    return [];
  } finally {
    if (connection) await connection.close();
  }
}

// =============================================================================
// CONVERSATION CONTEXT - Persistent session memory (NEW - Personal AI Upgrade)
// =============================================================================

async function initConversationContextTable(): Promise<void> {
  let connection;
  try {
    connection = await oracledb.getConnection(dbConfig);
    await connection.execute(`
      CREATE TABLE conversation_context (
        user_id NUMBER PRIMARY KEY,
        active_project VARCHAR2(100),
        active_file VARCHAR2(500),
        recent_files CLOB,
        recent_questions CLOB,
        pending_fixes CLOB,
        batch_edits CLOB,
        last_updated TIMESTAMP DEFAULT CURRENT_TIMESTAMP
      )
    `);
    await connection.commit();
    console.log('‚úÖ Conversation context table created');
  } catch (err: any) {
    if (err.errorNum === 955) {
      // Table already exists - this is fine
    } else {
      console.error('Conversation context table error:', err);
    }
  } finally {
    if (connection) await connection.close();
  }
}

interface ConversationContextData {
  activeProject: string | null;
  activeFile: string | null;
  recentFiles: { repo: string; path: string; content: string; timestamp: number }[];
  recentQuestions: { question: string; answer: string; timestamp: number }[];
  pendingFixes: { description: string; code: string; file?: string }[];
  batchEdits: { repo: string; path: string; content: string; sha: string }[];
  lastUpdated: number;
}

async function saveConversationContext(userId: number, context: ConversationContextData): Promise<boolean> {
  let connection;
  try {
    connection = await oracledb.getConnection(dbConfig);
    await connection.execute(
      `MERGE INTO conversation_context cc
       USING (SELECT :userId as user_id FROM dual) src
       ON (cc.user_id = src.user_id)
       WHEN MATCHED THEN UPDATE SET 
         active_project = :activeProject,
         active_file = :activeFile,
         recent_files = :recentFiles,
         recent_questions = :recentQuestions,
         pending_fixes = :pendingFixes,
         batch_edits = :batchEdits,
         last_updated = CURRENT_TIMESTAMP
       WHEN NOT MATCHED THEN INSERT (user_id, active_project, active_file, recent_files, recent_questions, pending_fixes, batch_edits)
       VALUES (:userId, :activeProject, :activeFile, :recentFiles, :recentQuestions, :pendingFixes, :batchEdits)`,
      {
        userId,
        activeProject: context.activeProject || null,
        activeFile: context.activeFile || null,
        recentFiles: JSON.stringify(context.recentFiles || []),
        recentQuestions: JSON.stringify(context.recentQuestions || []),
        pendingFixes: JSON.stringify(context.pendingFixes || []),
        batchEdits: JSON.stringify(context.batchEdits || [])
      },
      { autoCommit: true }
    );
    return true;
  } catch (err) {
    console.error('‚ùå Save conversation context error:', err);
    return false;
  } finally {
    if (connection) await connection.close();
  }
}

async function loadConversationContext(userId: number): Promise<ConversationContextData | null> {
  let connection;
  try {
    connection = await oracledb.getConnection(dbConfig);
    const result = await connection.execute(
      `SELECT active_project, active_file, recent_files, recent_questions, pending_fixes, batch_edits, last_updated
       FROM conversation_context WHERE user_id = :userId`,
      { userId }
    );
    if (result.rows && result.rows.length > 0) {
      const row = result.rows[0] as any[];
      return {
        activeProject: row[0],
        activeFile: row[1],
        recentFiles: JSON.parse(row[2] || '[]'),
        recentQuestions: JSON.parse(row[3] || '[]'),
        pendingFixes: JSON.parse(row[4] || '[]'),
        batchEdits: JSON.parse(row[5] || '[]'),
        lastUpdated: row[6] ? new Date(row[6]).getTime() : Date.now()
      };
    }
    return null;
  } catch (err) {
    console.error('‚ùå Load conversation context error:', err);
    return null;
  } finally {
    if (connection) await connection.close();
  }
}

async function clearConversationContext(userId: number): Promise<boolean> {
  let connection;
  try {
    connection = await oracledb.getConnection(dbConfig);
    await connection.execute(
      `DELETE FROM conversation_context WHERE user_id = :userId`,
      { userId },
      { autoCommit: true }
    );
    return true;
  } catch (err) {
    console.error('‚ùå Clear conversation context error:', err);
    return false;
  } finally {
    if (connection) await connection.close();
  }
}

// =============================================================================
// KNOWLEDGE BASE - Personal ideas, diary, notes, tasks (NEW - Personal AI Upgrade)
// =============================================================================

async function initKnowledgeBaseTable(): Promise<void> {
  let connection;
  try {
    connection = await oracledb.getConnection(dbConfig);
    await connection.execute(`
      CREATE TABLE knowledge_base (
        id RAW(16) DEFAULT SYS_GUID() PRIMARY KEY,
        user_id NUMBER NOT NULL,
        category VARCHAR2(50),
        title VARCHAR2(500),
        content CLOB,
        tags VARCHAR2(500),
        project VARCHAR2(100),
        source VARCHAR2(50),
        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
        updated_at TIMESTAMP
      )
    `);
    await connection.commit();
    console.log('‚úÖ Knowledge base table created');
  } catch (err: any) {
    if (err.errorNum === 955) {
      // Table already exists - this is fine
    } else {
      console.error('Knowledge base table error:', err);
    }
  } finally {
    if (connection) await connection.close();
  }
}

async function saveKnowledge(
  userId: number,
  category: string,
  title: string,
  content: string,
  tags?: string,
  project?: string,
  source: string = 'text'
): Promise<string | null> {
  let connection;
  try {
    connection = await oracledb.getConnection(dbConfig);
    const result = await connection.execute(
      `INSERT INTO knowledge_base (user_id, category, title, content, tags, project, source)
       VALUES (:userId, :category, :title, :content, :tags, :project, :source)
       RETURNING RAWTOHEX(id) INTO :id`,
      {
        userId,
        category,
        title: title.substring(0, 500),
        content,
        tags: tags?.substring(0, 500) || null,
        project: project || null,
        source,
        id: { dir: oracledb.BIND_OUT, type: oracledb.STRING, maxSize: 32 }
      },
      { autoCommit: true }
    );
    const outBinds = result.outBinds as { id: string[] };
    console.log(`üí° Knowledge saved: ${category} - ${title.substring(0, 30)}...`);
    return outBinds.id[0] || null;
  } catch (err) {
    console.error('‚ùå Save knowledge error:', err);
    return null;
  } finally {
    if (connection) await connection.close();
  }
}

async function searchKnowledge(
  userId: number,
  query: string,
  category?: string,
  limit: number = 10
): Promise<any[]> {
  let connection;
  try {
    connection = await oracledb.getConnection(dbConfig);
    let sql = `SELECT RAWTOHEX(id) as id, category, title, content, tags, project, source, created_at
               FROM knowledge_base 
               WHERE user_id = :userId 
               AND (UPPER(title) LIKE UPPER(:query) OR UPPER(content) LIKE UPPER(:query) OR UPPER(tags) LIKE UPPER(:query))`;
    const params: any = { userId, query: `%${query}%`, limit };
    
    if (category) {
      sql += ` AND category = :category`;
      params.category = category;
    }
    sql += ` ORDER BY created_at DESC FETCH FIRST :limit ROWS ONLY`;
    
    const result = await connection.execute(sql, params);
    return result.rows || [];
  } catch (err) {
    console.error('‚ùå Search knowledge error:', err);
    return [];
  } finally {
    if (connection) await connection.close();
  }
}

async function getKnowledgeByCategory(
  userId: number,
  category: string,
  limit: number = 20
): Promise<any[]> {
  let connection;
  try {
    connection = await oracledb.getConnection(dbConfig);
    const result = await connection.execute(
      `SELECT RAWTOHEX(id) as id, category, title, content, tags, project, source, created_at
       FROM knowledge_base 
       WHERE user_id = :userId AND category = :category
       ORDER BY created_at DESC FETCH FIRST :limit ROWS ONLY`,
      { userId, category, limit }
    );
    return result.rows || [];
  } catch (err) {
    console.error('‚ùå Get knowledge by category error:', err);
    return [];
  } finally {
    if (connection) await connection.close();
  }
}

async function getRecentKnowledge(
  userId: number,
  days: number = 7,
  limit: number = 20
): Promise<any[]> {
  let connection;
  try {
    connection = await oracledb.getConnection(dbConfig);
    const result = await connection.execute(
      `SELECT RAWTOHEX(id) as id, category, title, content, tags, project, source, created_at
       FROM knowledge_base 
       WHERE user_id = :userId 
       AND created_at > CURRENT_TIMESTAMP - INTERVAL '${days}' DAY
       ORDER BY created_at DESC FETCH FIRST :limit ROWS ONLY`,
      { userId, limit }
    );
    return result.rows || [];
  } catch (err) {
    console.error('‚ùå Get recent knowledge error:', err);
    return [];
  } finally {
    if (connection) await connection.close();
  }
}

// Initialize new tables (including Personal AI tables)
initLessonsTable();
initStrategicTable();
initHealthTable();
initConversationContextTable();
initKnowledgeBaseTable();

export { 
  initializeDatabase, 
  saveMemory, 
  getRelevantMemory,
  // Tech debt
  addTechDebt,
  getTechDebt,
  resolveTechDebt,
  // Decisions
  addDecision,
  getDecisions,
  // Pending code
  savePendingCode,
  getPendingCode,
  clearPendingCode,
  // Alerts
  getAlertPreferences,
  setAlertPreferences,
  getAllAlertChatIds,
  // Lessons learned
  saveLesson,
  getLessons,
  getSuccessPatterns,
  // Strategic
  saveInsight,
  getActiveInsights,
  resolveInsight,
  // Health
  saveHealthCheck,
  getHealthHistory,
  // Conversation Context (Personal AI Upgrade)
  saveConversationContext,
  loadConversationContext,
  clearConversationContext,
  // Knowledge Base (Personal AI Upgrade)
  saveKnowledge,
  searchKnowledge,
  getKnowledgeByCategory,
  getRecentKnowledge
};
